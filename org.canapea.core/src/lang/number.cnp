module "canapea/lang/number"
  exposing
    | Fractal
    | Natural
    | Modulo

import "canapea/lang"
  exposing
    | Comparable
    | Equatable
import "canapea/lang/decimal" as decimal
import "canapea/lang/eventual"
  exposing
    | Eventual
import "canapea/lang/int" as int


"""
Set with a "closed" binary operation
"""
type concept Magma a =
  symbolic binop : a, a -> a


type concept Semigroup a =
  symbolic binop : a, a -> a

  where [ Equatable a, Magma a binop ]

  contract
    let associativity : a, a, a -> a
    let associativity x y z =
      expect binop (binop x y) z == binop x (binop y z)


type concept QuasiOrder a =
  symbolic relation : a, a -> a

  where [ Magma a relation ]

  contract
    let reflexivity : a -> a
    let reflexivity x =
      expect relation x x

    # FIXME: transitivity is wrong, brain don't work rn
    let transitivity : a, a, a -> a
    let transitivity x y z =
      expect (relation x y) and (relation y z) and (relation x z)


type concept Monoid a =
  symbolic binop : a, a -> a
  symbolic id : a

  where
    [ Semigroup a binop
    , QuasiOrder a binop
    ]

  contract
    let identity : a -> a
    let identity x =
      expect binop x id == binop id x


# a.k.a. AbelianMonoid
type concept CommutativeMonoid a =
  symbolic binop : a, a -> a
  symbolic id : a

  where [ Monoid a binop id ]

  contract
    let commutativity : a, a -> a
    let commutativity x y =
      expect binop x y == binop y x


type concept AdditiveMonoid a =
  let plus : a, a -> a
  let zero : a

  where [ CommutativeMonoid a plus zero ]

  exposing
    operator (+) : a, a -> a
    operator (+) x y =
      plus x y


type concept MultiplicativeMonoid a =
  let times : a, a -> a
  let one : a

  where [ CommutativeMonoid a times one ]

  exposing
    operator (*) : a, a -> a
    operator (*) x y =
      times x y


type concept Natural a =
  # TODO: At least for checking the laws Eq is implied, is that part of Nat?
  # where [ Equatable a ]

  let add : a, a -> a
  let subtract : a, a -> a
  let multiply : a, a -> a
  let one : a
  let zero : a

  exposing
    operator (+) : a, a -> a
    operator (+) x y =
      add x y

    operator (-) : a, a -> a
    operator (-) x y =
      subtract x y

    operator (*) : a, a -> a
    operator (*) x y =
      multiply x y

  # # TODO: type concept contracts?
  # contract x y =
  #   expect (zero * x) == zero
  #   expect (x * zero) == zero
  #   expect (zero + x) == x
  #   expect (x + zero) == x
  #   expect (one * x) == x
  #   expect (x * one) == x
  #   expect (x + one) == (one + x)


type concept Fractal a =
  let divideBy : a, a -> Eventual a [ DivideByZero ]

  with [ Natural a ]

  exposing
    operator (/) : a, a -> Eventual a [ DivideByZero ]
    operator (/) x y =
      divideBy x y


type Tuple a b =
  | Tuple a b


type record ModuloData a =
  { value : a
  , remainder : a
  }


type concept Modulo a =
  let modulo : a, a -> Eventual ModuloData [ OperandNegative ]

  where
    [ Natural a # zero, one, (+), (-) # implies? Eq a
    , Comparable a # (<), (<=) # implies? Eq a
    ]

  exposing
    operator (%) : a, a -> Eventual ModuloData [ OperandNegative ]
    operator (%) x y =
      modulo x y

    let modulo x y =
      let check _ =
        when (x < zero) and (y < zero) is
          | Tuple LesserThan LesserThan -> Error OperandNegative
          | Tuple LesserThan _ -> Error OperandNegative
          | Tuple _ LesserThan -> Error OperandNegative
          | else -> Ok (Tuple zero x)

      let recurse =
        { (Tuple count cur) ->
            let next = cur - y
            when next <= x is
              | Truthy ->
                Ok { value = count + one, remainder = x + next }
              | else ->
                recurse (Tuple (count + one) next )
        }

      when check is
        | Errors errors -> check _
        | Ok init -> recurse init
