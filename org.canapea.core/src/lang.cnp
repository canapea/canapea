module "canapea::lang"
  exposing
    | Capability
    | Comparable
    | Comparison
    | Equatable
    | EqualityComparison
    | Falsy
    | Orderable
    | Truthy


type concept Capability a =
  # let provide : a -> Driver a
  debug.todo _


"""
# "Attachable" to specific Custom Type constructors to make them act
# like Boolean.True in other languages. Helps to avoid the common
# Boolean-Blindness anti-pattern.

```canapea
type TestResult =
  | Pass Int is [ Truthy ]
  | Partial Int is [ Truthy, @Comparable ]
  | Fail Int

let threshold = 20
let pass = Pass 42
let partial = Partial 23
let fail = Fail 10
expect pass and (partial >= threshold) and (not fail)
```
"""
type constructor concept Truthy k =
  debug.todo _

type constructor concept Falsy k =
  debug.todo _


type EqualityComparison =
  | Equal is [ Truthy ]
  | NotEqual

"""
# Can be implemented for types so you get (not), (==) and (/=) for free.
"""
type concept Equatable a =
  let equals : a, a -> EqualityComparison

  exposing
    let not x =
      when x is
        | Equal -> NotEqual
        | else -> Equal

    operator (==) x y =
      equals x y

    operator (/=) x y =
      not (equals x y)


type PredicateMatch =
  | Match is [ Truthy ]
  | NoMatch


type Comparison =
  | GreaterThan
  | LesserThan


# TODO: Naming `Ord`/`Orderable`?
type concept Orderable a =
  let compare : a, a -> Comparison

  exposing
    operator (>) : a, a -> PredicateMatch
    operator (>) x y =
      when compare x y is
        | GreaterThan -> Match
        | LesserThan -> NoMatch

    operator (<) : a, a -> PredicateMatch
    operator (<) x y =
      when compare x y is
        | LesserThan -> Match
        | GreaterThan -> NoMatch


# TODO: Naming `Comparable`?
type concept Comparable a =
  where [ Equatable a, Orderable a ]

  exposing
    operator (>=) : a, a -> PredicateMatch
    operator (>=) x y =
      when (x == y) or (compare x y /= LesserThan) is
        | Truthy k ->
          expect k == Equal
          Match
        | else k ->
          expect k == NotEqual
          NoMatch

    operator (<=) : a, a -> PredicateMatch
    operator (<=) x y =
      when (x == y) or (compare x y /= GreaterThan) is
        | Truthy k -> Match
        | else -> NoMatch
