===
Simple function with trivial body
===

module

function identity x =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_param
      (identifier))
    (eq)
    body: (value_expression
      (identifier))))

===
Simple function with multiple params
===

module

function fst x y z =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_param
      (identifier))
    (function_param
      (identifier))
    (function_param
      (identifier))
    (eq)
    body: (value_expression
      (identifier))))

===
Function with record pattern parameter
===

module

function pickX { x, y, z } =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_param
      (record_pattern
        (simple_record_key)
        (simple_record_key)
        (simple_record_key)))
    (eq)
    body: (value_expression
      (identifier))))

===
Simple anonymous function via top-level let binding
===

module

let giveMeTheAnswer = { 42 }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (int_literal))))

===
Simple anonymous function via function declaration
===

module

function giveMeTheAnswer =
  { 42 }

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    (identifier)
    (eq)
    (anonymous_function_expression
      (int_literal))))

===
Anonymous function with params via top-level let binding
===

module

let giveMeTheAnswer =
  { x -> x }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_param
        (identifier))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with pattern params via top-level let binding
===

module

let pickX =
  { { x, y, z } -> x }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_param
        (record_pattern
          (simple_record_key)
          (simple_record_key)
          (simple_record_key)))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with pattern and normal params via top-level let binding
===

module

let pickY =
  { x, { y }, z -> y }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_param
        (identifier))
      (function_param
        (record_pattern
          (simple_record_key)))
      (function_param
        (identifier))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with params and itermittent let bindings via top-level let binding
===

module

let giveMeTheAnswer =
  { x ->
    let y = 1
    let z = 2
    42
  }


---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_param
        (identifier))
      (arrow)
      (let_expression
        (let)
        (identifier)
        (eq)
        (int_literal))
      (let_expression
        (let)
        (identifier)
        (eq)
        (int_literal))
      (int_literal))))

===
Compact anonymous function with when expression body via top-level let binding
===

module

let result =
  { when it is
    | 42 -> "The Answer"
    | else -> "No idea"
  }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (when_expression
        (when)
        (value_expression
          (identifier))
        (is)
        (when_branch
          (when_branch_pattern
            (int_literal))
          (arrow)
          (when_branch_consequence
            (string_literal)))
        (when_branch
          (when_branch_pattern
            (else))
          (arrow)
          (when_branch_consequence
            (string_literal)))))))
