===
Line comments
===

# Comment outside module

module

# Comment inside module

function _ x = # Comment after function declaration
  # Comment in function body
  x # Comment after expression

# Comment after function

---


(source_file
  (comment)
  (module_declaration
    (module))
  (comment)
  (function_declaration
    (function)
    (identifier)
    (function_param
      (identifier))
    (eq)
    (comment)
    (comment)
    (value_expression
      (identifier)))
  (comment)
  (comment))


===
Toplevel let binding to Int literal
===

module

let zero = 0
let answer = 42
let notTheAnswer = -42
let largeNumber = 1_000_000

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (int_literal))
  (let_expression
    (let)
    (identifier)
    (eq)
    (int_literal))
  (let_expression
    (let)
    (identifier)
    (eq)
    (int_literal))
  (let_expression
    (let)
    (identifier)
    (eq)
    (int_literal)))



===
Toplevel let binding to String literal
===

module

let string = "this is a string"

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (string_literal)))


===
Toplevel let binding to record expression
===

module

let string =
  { simple = "record"
  , number = -1
  }

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (record_expression
      (record_expression_entry
        (simple_record_key)
        (eq)
        (string_literal))
      (record_expression_entry
        (simple_record_key)
        (eq)
        (int_literal)))))




===
Toplevel let binding to sequence expression
===

module

let sequence =
  [ "some"
  , "sequence"
  ]

let splatted =
  [ ...splat
  , "some"
  , ...splaat
  , "sequence"
  , ...splaaat
  ]

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (sequence_expression
      (sequence_expression_entry
        (string_literal))
      (sequence_expression_entry
        (string_literal))))
  (let_expression
    (let)
    (identifier)
    (eq)
    (sequence_expression
      (sequence_expression_entry
        (sequence_expression_splat
          (dotdotdot)
          (sequence_expression_splat_identifier)))
      (sequence_expression_entry
        (string_literal))
      (sequence_expression_entry
        (sequence_expression_splat
          (dotdotdot)
          (sequence_expression_splat_identifier)))
      (sequence_expression_entry
        (string_literal))
      (sequence_expression_entry
        (sequence_expression_splat
          (dotdotdot)
          (sequence_expression_splat_identifier))))))
      


===
Simple when expression via top-level let binding
===

module

let a =
  when a is
  | 1 -> 2
  | else -> 0

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (when_expression
      (when)
      (value_expression
        (identifier))
      (is)
      (int_literal)
      (int_literal)
      (else)
      (int_literal))))


===
Complex when expression with guard via top-level let binding
===

module

let a =
  when a is
  | { m } where m == 1 -> m
  | [ _, n, ...rest ] where n == 2 -> rest
  | 3 -> a
  | else -> 0

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (when_expression
      (when)
      (value_expression
        (identifier))
      (is)
      (record_pattern
        (simple_record_key))
      (where)
      (when_pattern_guard
        (conditional_expression
          (value_expression
            (identifier))
          (eqeq)
          (int_literal)))
      (value_expression
        (identifier))
      (sequence_pattern
        (identifier)
        (identifier)
        (rest_args
          (dotdotdot)
          (rest_args_identifier)))
      (where)
      (when_pattern_guard
        (conditional_expression
          (value_expression
            (identifier))
          (eqeq)
          (int_literal)))
      (value_expression
        (identifier))
      (int_literal)
      (value_expression
        (identifier))
      (else)
      (int_literal))))


===
Simple call expression via top-level let binding
===

module

let a = fn "arg"

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (call_expression
      (identifier)
      (string_literal))))



===
Simple call expression on qualified identifier via top-level let binding
===

module

let a = lib.fn "arg"

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (call_expression
      (qualified_accessor
        (identifier)
        (dot)
        (identifier))
      (string_literal))))




===
Expressions surrounded in parens via top-level let binding
===

module

let int = (1)
let string = ("a string")
let function = f (g 1 "blubb") (lib.compute { x = 42 })

---


(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (int_literal))
  (let_expression
    (let)
    (identifier)
    (eq)
    (string_literal))
  (let_expression
    (let)
    (identifier)
    (eq)
    (call_expression
      (identifier)
      (call_expression
        (identifier)
        (int_literal)
        (string_literal))
      (call_expression
        (qualified_accessor
          (identifier)
          (dot)
          (identifier))
        (record_expression
          (record_expression_entry
            (simple_record_key)
            (eq)
            (int_literal)))))))
          


