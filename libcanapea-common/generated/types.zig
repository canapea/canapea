//! Generated code from internal parser artifacts
//! DO NOT MODIFY BY HAND

const std = @import("std");
const testing = std.testing;

test GrammarRule {
    try testing.expect(1 == 1);
}

/// Generated from parser artifacts
const GrammarRule = enum {
    source_file,
    comment,
    toplevel_docs,
    type_annotation,
    operator_type_annotation,
    application_declaration,
    application_config_declaration,
    module_declaration,
    development_module_declaration,
    module_export_list,
    _module_export_type,
    module_export_type_with_constructors,
    module_export_opaque_type,
    module_export_value,
    application_imports,
    import_capability_clause,
    module_imports,
    import_clause,
    import_expose_list,
    import_expose_type,
    import_expose_type_constructor,
    _toplevel_declarations,
    _free_type_annotation,
    _development_toplevel_declarations,
    test_expectation,
    todo_expression,
    function_declaration,
    function_parameter,
    _block_body,
    record_pattern,
    sequence_pattern,
    custom_type_pattern,
    _complex_custom_type_pattern,
    _call_or_atom,
    _atom,
    _atom_in_parens,
    _atom_not_in_parens,
    _literal_expression,
    value_expression,
    let_expression,
    anonymous_function_expression,
    record_expression,
    record_expression_entry,
    sequence_expression,
    sequence_expression_entry,
    conditional_expression,
    when_expression,
    when_branch,
    when_branch_catchall,
    when_branch_pattern,
    when_branch_pattern_guard,
    when_branch_consequence,
    call_expression,
    call_target,
    call_parameter,
    custom_type_declaration,
    custom_type_constructor_declaration,
    custom_type_constructor_applied_concept,
    custom_type_constructor,
    custom_type_expression,
    custom_type_trivial_value_expression,
    record_declaration,
    record_type_expression,
    record_type_entry,
    module_name_definition,
    module_import_name,
    qualified_access_expression,
    _field_access_target,
    type_concept_declaration,
    type_constructor_concept_declaration,
    type_concept_requirements,
    _type_concept_required_constraints,
    type_concept_constraint,
    type_concept_required_declaration,
    type_concept_implementation,
    type_constructor_concept_implementation,
    binary_operator_declaration,
    binary_operator_expression,
    type_concept_instance_declaration,
    type_concept_instance_implementation,
    string_literal,
    multiline_string_literal,
    application,
    config,
    module,
    as,
    exposing,
    import,
    type,
    record,
    let,
    when,
    is,
    where,
    debug,
    expect,
    todo,
    canapea,
    experimental,
    concept,
    constructor,
    instance,
    contract,
    operator,
    capability,
    dot,
    _dotdot,
    dotdotdot,
    eq,
    _pipe,
    arrow,
    parenL,
    _parenL,
    parenR,
    _parenR,
    _curlyL,
    _curlyR,
    _bracketL,
    _bracketR,
    pathSep,
    colon,
    _comma,
    pipe_operator,
    maths_operator,
    module_name_path_fragment,
    simple_record_key,
    int_literal,
    decimal_literal,
    string_escape,
    invalid_string_escape,
    rest_args,
    rest_args_identifier,
    sequence_expression_splat,
    sequence_expression_splat_identifier,
    record_expression_splat,
    record_expression_splat_identifier,
    identifier,
    uppercase_identifier,
    custom_type_constructor_name,
    type_concept_name,
    capability_name,
    named_module_import,
    dont_care,
    _identifier_without_leading_whitespace,
    _dot_without_leading_whitespace,
    type_variable,
    _implicit_block_open,
    _implicit_block_close,
};
