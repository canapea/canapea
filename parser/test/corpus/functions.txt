===
Simple function with trivial body
===

module

function identity x =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_parameter
      (identifier))
    (eq)
    body: (value_expression
      (identifier))))

===
Simple function with multiple params
===

module

function fst x y z =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_parameter
      (identifier))
    (function_parameter
      (identifier))
    (function_parameter
      (identifier))
    (eq)
    body: (value_expression
      (identifier))))

===
Function with record pattern parameter
===

module

function pickX { x, y, z } =
  x

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_parameter
      (record_pattern
        (simple_record_key)
        (simple_record_key)
        (simple_record_key)))
    (eq)
    body: (value_expression
      (identifier))))

===
Function with sequence pattern parameter
===

module

function pickY [x, y, ...rest] =
  y

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    name: (identifier)
    (function_parameter
      (sequence_pattern
        (identifier)
        (identifier)
        (rest_args
          (dotdotdot)
          (rest_args_identifier))))
    (eq)
    body: (value_expression
      (identifier))))

===
Simple anonymous function via top-level let binding
===

module

let giveMeTheAnswer = { 42 }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (int_literal))))

===
Simple anonymous function via function declaration
===

module

function giveMeTheAnswer =
  { 42 }

---

(source_file
  (module_declaration
    (module))
  (function_declaration
    (function)
    (identifier)
    (eq)
    (anonymous_function_expression
      (int_literal))))

===
Anonymous function with params via top-level let binding
===

module

let giveMeTheAnswer =
  { x -> x }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_parameter
        (identifier))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with pattern params via top-level let binding
===

module

let pickX =
  { { x, y, z } -> x }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_parameter
        (record_pattern
          (simple_record_key)
          (simple_record_key)
          (simple_record_key)))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with pattern and normal params via top-level let binding
===

module

let pickY =
  { x, { y }, z -> y }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_parameter
        (identifier))
      (function_parameter
        (record_pattern
          (simple_record_key)))
      (function_parameter
        (identifier))
      (arrow)
      (value_expression
        (identifier)))))

===
Anonymous function with params and itermittent let bindings via top-level let binding
===

module

let giveMeTheAnswer =
  { x ->
    let y = 1
    let z = 2
    42
  }


---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (function_parameter
        (identifier))
      (arrow)
      (let_expression
        (let)
        (identifier)
        (eq)
        (int_literal))
      (let_expression
        (let)
        (identifier)
        (eq)
        (int_literal))
      (int_literal))))

===
Compact anonymous function with when expression body via top-level let binding
===

module

let result =
  { when it is
    | 42 -> "The Answer"
    | else -> "No idea"
  }

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (anonymous_function_expression
      (when_expression
        (when)
        (value_expression
          (identifier))
        (is)
        (when_branch
          (when_branch_pattern
            (int_literal))
          (arrow)
          (when_branch_consequence
            (string_literal)))
        (when_branch_catchall
          (else)
          (arrow)
          (when_branch_consequence
            (string_literal)))))))

===
Piping int value into function via builtin (|>) forward pipe operator
===

module

let result =
  41 |> add 1

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (operator_expression
      (int_literal)
      (operator
        (operator_identifier))
      (call_expression
        (call_target
          (identifier))
        (call_parameter
          (int_literal))))))

===
Mapping over sequence multiple times via builtin (|>) forward pipe operator
===

module

let result =
  [ 40, 41, 42 ]
    |> map addOne
    |> map math.times2

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (operator_expression
      (operator_expression
        (sequence_expression
          (sequence_expression_entry
            (int_literal))
          (sequence_expression_entry
            (int_literal))
          (sequence_expression_entry
            (int_literal)))
        (operator
          (operator_identifier))
        (call_expression
          (call_target
            (identifier))
          (call_parameter
            (value_expression
              (identifier)))))
      (operator
        (operator_identifier))
      (call_expression
        (call_target
          (identifier))
        (call_parameter
          (qualified_accessor
            (identifier)
            (dot)
            (identifier)))))))

===
Mapping over sequence with explicit parens via (|>) should yield the same associativity grouping as leaving the parens out.
===

module

let result =
  (([ 40, 41, 42 ] |> map addOne)
    |> map math.times2
  )

---

(source_file
  (module_declaration
    (module))
  (let_expression
    (let)
    (identifier)
    (eq)
    (parenL)
    (operator_expression
      (parenL)
      (operator_expression
        (sequence_expression
          (sequence_expression_entry
            (int_literal))
          (sequence_expression_entry
            (int_literal))
          (sequence_expression_entry
            (int_literal)))
        (operator
          (operator_identifier))
        (call_expression
          (call_target
            (identifier))
          (call_parameter
            (value_expression
              (identifier)))))
      (parenR)
      (operator
        (operator_identifier))
      (call_expression
        (call_target
          (identifier))
        (call_parameter
          (qualified_accessor
            (identifier)
            (dot)
            (identifier)))))
    (parenR)))
