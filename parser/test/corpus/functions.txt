===
PTC0033: Simple function with trivial body
===

module

let identity x =
  x

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (function_declaration
      (let)
      name: (identifier)
      (function_parameter
        name: (identifier))
      (eq)
      body: (block
        single_return: (value_expression
          (identifier))))))

===
PTC0034: Simple function with multiple parameters
===

module

let fst x y z =
  x

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (function_declaration
      (let)
      name: (identifier)
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier))
      (function_parameter
        name: (identifier))
      (eq)
      body: (block
        single_return: (value_expression
          (identifier))))))

===
PTC0035: Function with record pattern parameter
===

module

let pickX { x, y, z } =
  x

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (function_declaration
      (let)
      name: (identifier)
      (function_parameter
        (record_pattern
          (simple_record_key)
          (simple_record_key)
          (simple_record_key)))
      (eq)
      body: (block
        single_return: (value_expression
          (identifier))))))

===
PTC0036: Function with sequence pattern parameter
===

module

let pickY [_, looooooooooooong, ...rest] =
  looooooooooooong

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (function_declaration
      (let)
      name: (identifier)
      (function_parameter
        (sequence_pattern
          (dont_care)
          (identifier)
          (rest_args
            (identifier))))
      (eq)
      body: (block
        single_return: (value_expression
          (identifier))))))

===
PTC0037: Function with custom type pattern parameter
===

module

let extract (Id id) =
  id

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (function_declaration
      (let)
      (identifier)
      (function_parameter
        (custom_type_pattern
          (custom_type_constructor_name)
          (identifier)))
      (eq)
      (block
        (value_expression
          (identifier))))))

===
PTC0038: Simple anonymous function via top-level let binding
===

module

let giveMeTheAnswer = { 42 }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (block
            (value_expression
              (int_literal))))))))

===
PTC0039: Simple anonymous function bound via function declaration
===

module

let giveMeTheAnswer =
  { 42 }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (block
            (value_expression
              (int_literal))))))))

===
PTC0040: Anonymous function with params via top-level let binding
===

module

let giveMeTheAnswer =
  { x -> x }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (function_parameter
            (identifier))
          (arrow)
          (block
            (value_expression
              (identifier))))))))

===
PTC0041: Anonymous function with pattern params via top-level let binding
===

module

let pickX =
  { { x, y, z } -> x }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (function_parameter
            (record_pattern
              (simple_record_key)
              (simple_record_key)
              (simple_record_key)))
          (arrow)
          (block
            (value_expression
              (identifier))))))))

===
PTC0042: Anonymous function with pattern and normal params via top-level let binding
===

module

let pickY =
  { x { y } [ _, z, ...rest ] (Id id) -> id }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (function_parameter
            (identifier))
          (function_parameter
            (record_pattern
              (simple_record_key)))
          (function_parameter
            (sequence_pattern
              (dont_care)
              (identifier)
              (rest_args
                (identifier))))
          (function_parameter
            (custom_type_pattern
              (custom_type_constructor_name)
              (identifier)))
          (arrow)
          (block
            (value_expression
              (identifier))))))))

===
PTC0043: Anonymous function with params and itermittent let bindings via top-level let binding
===

module

let giveMeTheAnswer =
  { x ->
    let y = 1
    let z = 2
    42
  }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (function_parameter
            (identifier))
          (arrow)
          (block
            (let_expression
              (let)
              (identifier)
              (eq)
              (block
                (value_expression
                  (int_literal))))
            (let_expression
              (let)
              (identifier)
              (eq)
              (block
                (value_expression
                  (int_literal))))
            (value_expression
              (int_literal))))))))

===
PTC0044: Compact anonymous function with when expression body via top-level let binding
===

module

let result =
  { when it is
    | 42 -> "The Answer"
    | else -> "No idea"
  }

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (anonymous_function_expression
          (block
            (when_expression
              (when)
              (value_expression
                (identifier))
              (is)
              (when_branch
                (when_branch_pattern
                  (int_literal))
                (arrow)
                (when_branch_consequence
                  (value_expression
                    (string_literal))))
              (when_branch_catchall
                (else)
                (arrow)
                (when_branch_consequence
                  (value_expression
                    (string_literal)))))))))))

===
PTC0045: Piping int value into function via builtin (|>) forward pipe operator
===

module

let result =
  41 |> add 1

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (binary_pipe_expression
          (value_expression
            (int_literal))
          (pipe_operator)
          (call_expression
            (identifier)
            (call_parameter
              (value_expression
                (int_literal)))))))))

===
PTC0046: Mapping over sequence multiple times via builtin (|>) forward pipe operator
===

module

let result =
  [ 40, 41, 42 ]
    |> map addOne
    |> map math.times2

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (binary_pipe_expression
          (binary_pipe_expression
            (sequence_expression
              (sequence_expression_entry
                (value_expression
                  (int_literal)))
              (sequence_expression_entry
                (value_expression
                  (int_literal)))
              (sequence_expression_entry
                (value_expression
                  (int_literal))))
            (pipe_operator)
            (call_expression
              (identifier)
              (call_parameter
                (value_expression
                  (identifier)))))
          (pipe_operator)
          (call_expression
            (identifier)
            (call_parameter
              (qualified_function_ref_expression
                (identifier)
                (dot)
                (identifier)))))))))

===
PTC0047: (regression) Mapping over sequence with explicit parens via (|>) should yield the same associativity grouping as leaving the parens out.
===

module

let result =
  (([ 40, 41, 42 ] |> map addOne)
    |> map math.times2
  )

---

(source_file
  (module_declaration
    (module_signature
      (module))
    (let_declaration
      (let)
      (identifier)
      (eq)
      (block
        (binary_pipe_expression
          (binary_pipe_expression
            (sequence_expression
              (sequence_expression_entry
                (value_expression
                  (int_literal)))
              (sequence_expression_entry
                (value_expression
                  (int_literal)))
              (sequence_expression_entry
                (value_expression
                  (int_literal))))
            (pipe_operator)
            (call_expression
              (identifier)
              (call_parameter
                (value_expression
                  (identifier)))))
          (pipe_operator)
          (call_expression
            (identifier)
            (call_parameter
              (qualified_function_ref_expression
                (identifier)
                (dot)
                (identifier)))))))))
